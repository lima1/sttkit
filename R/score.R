#' read_signatures
#'
#' Read signatures defined in a GMT file
#' @param gmt GMT file with gene signatures. Can also be a CSV file with
#' columns \code{gene} and \code{cluster} as generated by \code{\link{find_markers}}
#' @param obj Seurat object, used to filter signatures for non-available genes
#' @param max_nchar_title Truncate signature name 
#' @export read_signatures
#' @importFrom tools file_ext
#' @importFrom utils read.csv
#' @examples
#' read_signatures()
    
read_signatures <- function(gmt, obj = NULL, max_nchar_title = 25) {
    if (!file.exists(gmt)) {
        gmts <- strsplit(gmt, ":")[[1]]
        if (length(gmts) > 1) {
            return( do.call(c, lapply(gmts, read_signatures, obj = obj, max_nchar_title = max_nchar_title)))
        } 
    }    
    if (file_ext(gmt) == "csv") {
        x <- read.csv(gmt, as.is = TRUE)
        sigs <- lapply(split(x$gene, x$cluster), sort)
    } else {
        sigs <- suppressMessages(.read.gmt(gmt))
    }
    names(sigs) <- sapply(trimws(names(sigs)),
        function(x) if (nchar(x) <= max_nchar_title) return(x) else return(paste0(substr(x, 1, max_nchar_title),"...")))

    if (!is.null(obj)) {
        do_make_names <- length(setdiff(unlist(sigs), rownames(obj))) <
            length(setdiff(make.names(unlist(sigs)), make.names(rownames(obj))))

        if (do_make_names) { 
            attrs <- attributes(sigs) 
            sigs <- lapply(sigs, make.names)
            attributes(sigs) <- attrs
        }    
        # check that features are available
        idx <- sapply(sigs, function(x) sum(x %in%  rownames(obj))) >= 1

        if (any(!idx)) {
            flog.warn("Removing signatures without available genes (%s)",
                paste(names(sigs)[!idx], collapse = ", "))
            sigs <- .remove_sigs(sigs, idx)
        }
    }
    return(sigs)
}

.remove_sigs <- function(sigs, idx) {
    # remove signatures safely
    attrs <- attributes(sigs) 
    sigs <- sigs[idx]
    attrs <- lapply(attrs, function(x) x[idx])
    attributes(sigs) <- attrs
    return(sigs)
}
    
.add_module_score <- function(obj, sigs, zero_offset, zero_cutoff = NULL, clean_names = TRUE, method = c("seurat", "mean"), assay = "Spatial", ...) {
    method <- match.arg(method)
    for (i in seq_along(sigs)) {
        idx <- sigs[[i]] %in% rownames(obj)
        if (any(!idx)) {
            flog.warn("Removing %i/%i unavailable genes in signature %s (%s)",
                length(unique(sigs[[i]][!idx])), 
                length(unique(sigs[[i]])), 
                names(sigs)[i], paste(sigs[[i]][!idx], collapse = ", "))
            sigs[[i]] <- sigs[[i]][idx]
        }
    }    
    if (method == "seurat") {
        obj <- AddModuleScore(obj, sigs, ...)
    } else {
        for (i in seq_along(sigs)) {
            obj <- find_signature_means(obj, sigs[[i]], 
                label = paste0(names(sigs)[i], i), fun = get(method))
        }
    }        
    sig_names <- .get_signature_names(obj, sigs)
    if (clean_names) {
        for (i in seq_along(sig_names)) {
            obj[[names(sigs)[i]]] <- obj[[sig_names[i]]]
            obj@meta.data[[sig_names[i]]] <- NULL
        }
    }
    obj
}

.get_signature_names <- function(obj, sigs) {
    sig_names <- colnames(obj@meta.data)[sapply(names(sigs), function(x) 
        grep(paste0("^",x, "\\d*$"), colnames(obj@meta.data))[1])]
}
#' calculate_nmf_gse
#'
#' Correlate gene signatures with NMF clusters
#' @param obj Object, clustered by \code{\link{cluster_nmf}}.
#' @param sig_set List of signatures, read by \code{\link{read_signatures}}.
#' @param method Method to calculate p-values
#' @param perm_n If \code{method="perm"}, number of permutations
#' @param scale If \code{method="perm"}, scale NMF basis
#' @param alternative If \code{method="perm"}, direction to test
#' @param min_nmf_features Minimum number of features for each NMF cluster.
#' Default means that top 50 genes associated with cluster are tested for 
#' enrichment.
#' @param summary_function If \code{method="perm"}, function to summarize 
#' gene signature scores
#' @param rank Number of clusters (the one used in \code{\link{cluster_nmf}})
#' @param k Features of rank to be written (must be a single k, not a range)
#' @param prefix Prefix of output files
#' @param verbose Verbose output
#' @export calculate_nmf_gse 
#' @examples
#' calculate_nmf_gse
#' @importFrom stats fisher.test
calculate_nmf_gse <- function(obj, sig_set, method = c("fisher", "perm"), 
    perm_n = 1000, scale = TRUE, alternative = c("two.sided", "less", "greater"), 
    min_nmf_features = 100, summary_function = mean, rank, k, prefix, verbose = TRUE) {
    nmf_obj <- .extract_nmf_obj(obj, rank)
    nmf_obj_f <- if (is(nmf_obj, "NMFfit")) nmf_obj else nmf_obj$fit[[as.character(k)]]
    # get signatures associated with each NMF cluster
    features <- .extract_nmf_features(nmf_obj_f, method = "kim", 
        min_features = min_nmf_features )
    idx <- sapply(features, function(x) !is.null(nrow(x)))
    nmf_sig_set <- lapply(features[idx], rownames)

    universe <- rownames(nmf_obj_f)
    method <- match.arg(method)

    for (i in seq_along(sig_set)) {
        missing <- sig_set[[i]][!sig_set[[i]] %in% universe]
        if (length(missing)) {
            if (verbose) flog.warn("Genes not available from signature %s: %s",
                names(sig_set)[i], paste0(missing, collapse=","))
            sig_set[[i]] <- sig_set[[i]][sig_set[[i]] %in% universe]
        }
    }
    sig_set <- .remove_sigs(sig_set, sapply(sig_set, length)>1)

    dups <- duplicated(sapply(sig_set, paste))
    if (any(dups)) {
        flog.info("Removing %i identical (after filtering) gene sets.", sum(dups))
        sig_set <- .remove_sigs(sig_set, !dups)
    }
    if (!length(sig_set)) {
        if (verbose) flog.warn("Empty signature. Skipping enrichment analysis.")
        return(NULL)    
    }    
    if (method == "fisher") {
        return(.calculate_nmf_gse_fisher(sig_set, nmf_sig_set, universe, verbose))
    } else if (method == "perm") {
        alternative <- match.arg(alternative)
        .calculate_nmf_gse_perm(sig_set, basis = NMF::basis(nmf_obj_f), 
            perm_n = perm_n, scale = scale, alternative = alternative, 
            summary_function = summary_function)
    } else {
        stop("Unknown method. Must be fisher or perm.")
    }            
}

.calculate_nmf_gse_fisher <- function(sig_set, nmf_sig_set, universe, verbose) {
    if (verbose) flog.info("Fisher's exact test on universe of size %i...", length(universe))
    ret <- lapply(nmf_sig_set, function(sig) {
        ranking <- do.call(rbind, lapply(sig_set, function(x) {
            overlap <- sum(x %in% sig)
            if (!overlap) return(data.frame(
                pvalue = 1,
                or = 0,
                overlap = 0, 
                size = length(x),
                size_nmf = length(sig),
                genes = ""))
            cont <- matrix(c(overlap, length(setdiff(sig, 
                x)), length(setdiff(x, sig)), length(universe)), nrow = 2)
            cont[2, 2] <- cont[2, 2] - cont[1, 1] - cont[1, 2] - 
                cont[2, 1]

            ft <- fisher.test(cont, alternative = "greater")
            # equivalent of:
            #gt <- phyper(overlap-1, length(x), length(universe)-length(x),
            #    length(sig), lower.tail = FALSE, log.p = FALSE)
            return(data.frame(
                pvalue = ft$p.value, 
                or = ft$estimate,
                overlap = overlap,
                size = length(x),
                size_nmf = length(sig),
                genes = paste0(x[x %in% sig], collapse=" ")))
        }))
        ranking <- ranking[order(ranking[,1], decreasing = FALSE),]
    })
    if (!is.null(attributes(sig_set)$descr)) {
        ret <- lapply(ret, function(x) data.frame(Descr=attributes(sig_set)$descr[match(rownames(x), names(sig_set))], x))
    }
    return(ret)
}

.calculate_nmf_gse_perm <- function(sig_set, basis, perm_n = 1000,
    scale = TRUE, alternative = c("two.sided", "less", "greater"), 
    summary_function = mean
 ) {
    .get_pvalue <- function(p) {
        if (alternative == "two.sided") {
            return(pmin(p, 1-p)/2) 
        } else if (alternative == "greater") {
            return(1-p)
        } else {
            return(p)
        }
    }
    if (scale) basis <- scale(basis)
    p <- lapply(seq(ncol(basis)), function(i) {
        ranking <- t(sapply(sig_set, function(x) {
        sig_summary <- summary_function(basis[x, i])
        idx <- replicate(perm_n, sample(nrow(basis), length(x)))
        permuted_summary <- apply(idx, 2, function(j) summary_function(basis[j,i]))
        c(sum(sig_summary < permuted_summary)/length(permuted_summary), sig_summary, mean(permuted_summary))
        }))
        ranking[,1] <- sapply(ranking[,1], .get_pvalue)
        ranking <- ranking[order(ranking[,1], decreasing = FALSE),]
    })
}                

#' find_signature_means
#'
#' A simple alternative to Seurat's \code{AddModuleScore}, simply
#' taking the signature mean without additional normalization
#' @param obj Seurat object or a normalized count matrix (row genes, col samples)
#' @param features \code{character(n)} of features
#' @param slot If \code{obj} is a Seurat object, the slot name
#' @param label If not \code{NULL}, a \code{obj@meta.data} column name
#' to store.
#' @param fun Function to summary signature
#' @export find_signature_means
#' @examples
#' find_signature_means()
find_signature_means <- function(obj, features, slot = "data", label = NULL, fun = mean) {
    if (is(obj, "Seurat")) {
        ncounts <- GetAssayData(object = obj, slot = slot)
    } else {
        ncounts <- obj
    }
    avail.genes <- rownames(ncounts)

    na.genes <- features[!features %in% avail.genes]
    if(length(na.genes) > 0) {
        warning(paste(c("gene not in the table", na.genes, "\n"),
                      sep = " ", collapse = " "))
        features <- features[features %in% avail.genes]
    }
    if (!length(features)) {
        warning("No feature in the signature available.")
        if (!is.null(label)) {
            return(obj)
        } else {
            return(NULL)
        }
    }
    score <- apply(ncounts[features, , drop = FALSE], 2, FUN = fun)
    if (!is.null(label)) {
        obj[[label]] <- score
        return(obj)
    }
    score
}

.read.gmt <- function (gmt_file) {
    sigs <- readLines(gmt_file)
    sigs <- strsplit(sigs, "\t")
    names(sigs) <- make.names(sapply(sigs, function(x) trimws(x[1])))
    descr <- sapply(sigs, function(x) trimws(x[2]))
    sigs <- lapply(sigs, function(x) unique(sort(trimws(x[-(1:2)]))))
    attributes(sigs)$descr <- descr
    empty <- names(which(sapply(sigs, function(x) any(nchar(x) < 1))))

    if (length(empty)) {
        flog.warn("%i signatures contain empty strings, removing them...",
            length(empty))
        sigs <- lapply(sigs, function(x) x[nchar(x) > 0])
    }
    return(sigs)
}

.write.gmt <- function (sigs, file_name) {
    nams <- names(sigs)
    descr <- sapply(sigs, function(x) paste(attributes(x)[[1]], collapse="_"))
    genes <- sapply(sigs, paste, collapse = "\t")
    gmt <- paste(nams, descr, genes, sep = "\t")
    writeLines(gmt, con = file(file_name))
    return(NULL)
}
